<!DOCTYPE html>
<html lang="en">
<head>
	<title>Galalea Local</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="shortcut icon" type="image/png" href="favicon.png"/>
	<style>
		html, body {
			width: 100%;
			height: 100%;
		}
		body {
			background-color: #ffffff;
			margin: 0;
			overflow: hidden;
			font-family: arial;
		}
		#blocker {
			position: absolute;
			width: 100%;
			height: 100%;
			background-color: rgba(0,0,0,0.5);
		}
		#instructions {
			width: 100%;
			height: 100%;
			display: -webkit-box;
			display: -moz-box;
			display: box;
			-webkit-box-orient: horizontal;
			-moz-box-orient: horizontal;
			box-orient: horizontal;
			-webkit-box-pack: center;
			-moz-box-pack: center;
			box-pack: center;
			-webkit-box-align: center;
			-moz-box-align: center;
			box-align: center;
			color: #ffffff;
			text-align: center;
			cursor: pointer;
		}
	</style>
</head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/90/three.js"></script>
	<script src="js/PointerLockControls.js"></script>
	<!--/************************************************-->
	<div id="blocker">

		<div id="instructions">
			<span style="font-size:40px">Click to play</span>
			<br />
			(W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
		</div>

	</div>
	<!--************************************************/-->
	<!--/************************************************-->
	
	<script type="application/x-glsl" id="sky-vertex">  
		varying vec2 vUV;

		void main() {  
		  vUV = uv;
		  vec4 pos = vec4(position, 1.0);
		  gl_Position = projectionMatrix * modelViewMatrix * pos;
		}
		</script>

		<script type="application/x-glsl" id="sky-fragment">  
		uniform sampler2D texture;  
		varying vec2 vUV;

		void main() {  
		  vec4 sample = texture2D(texture, vUV);
		  gl_FragColor = vec4(sample.xyz, sample.w);
		}
	</script>  
	<!--************************************************/-->


	<script>
		var camera, scene, renderer, controls;
		var objects = [];
		var raycaster;
		var blocker = document.getElementById( 'blocker' );
		//var instructions = document.getElementById( 'instructions' );
		var clock = new THREE.Clock();
     
		// http://www.html5rocks.com/en/tutorials/pointerlock/intro/
		///***************************************************
		
		var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
		if ( havePointerLock ) {
			var element = document.body;
			var pointerlockchange = function ( event ) {
				if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
					controlsEnabled = true;
					controls.enabled = true;
					blocker.style.display = 'none';
				} else {
					controls.enabled = false;
					blocker.style.display = 'block';
					instructions.style.display = '';
				}
			};
			var pointerlockerror = function ( event ) {
				instructions.style.display = '';
			};
			// Hook pointer lock state change events
			document.addEventListener( 'pointerlockchange', pointerlockchange, false );
			document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
			document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
			document.addEventListener( 'pointerlockerror', pointerlockerror, false );
			document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
			document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
			instructions.addEventListener( 'click', function ( event ) {
				instructions.style.display = 'none';
				// Ask the browser to lock the pointer
				element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
				element.requestPointerLock();
			}, false );
		} else {
			instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
		}
		//****************************************/
		init();
		animate();
		var controlsEnabled = false;
		var moveForward = false;
		var moveBackward = false;
		var moveLeft = false;
		var moveRight = false;
		var canJump = false;
		var prevTime = performance.now();
		var velocity = new THREE.Vector3();
		var direction = new THREE.Vector3();
		
		function init() {
			//1800
			camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 3000 );//1000
			//camera.position.set(0,-3,-100);

			camera.position.y = -3;

			//camera.position.y = 1500;
			//camera.rotation.x = -Math.PI / 2;
			scene = new THREE.Scene();
			scene.background = new THREE.Color( 0x43dafd );
			//scene.fog = new THREE.Fog( 0xffffff, 0, 750 );
			//eeeeff
			//777788
			/*
			var light = new THREE.HemisphereLight( 0xeeeeff, 0xfff3db, 0.75 );
			light.position.set( 0.5, 1, 0.75 );
			scene.add( light );
			*/

							// LIGHTS
			
			hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
			hemiLight.color.setHSL( 0.6, 1, 0.6 );
			hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
			hemiLight.position.set( 0, 50, 0 );
			scene.add( hemiLight );
			hemiLightHelper = new THREE.HemisphereLightHelper( hemiLight, 10 );
			scene.add( hemiLightHelper );
			//
			dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
			dirLight.color.setHSL( 0.1, 1, 0.95 );
			dirLight.position.set( -1, 1.75, 1 );
			dirLight.position.multiplyScalar( 30 );
			scene.add( dirLight );
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 2048;
			dirLight.shadow.mapSize.height = 2048;
			var d = 50;
			dirLight.shadow.camera.left = -d;
			dirLight.shadow.camera.right = d;
			dirLight.shadow.camera.top = d;
			dirLight.shadow.camera.bottom = -d;
			dirLight.shadow.camera.far = 3500;
			dirLight.shadow.bias = -0.0001;
			dirLightHeper = new THREE.DirectionalLightHelper( dirLight, 10 ) 
			scene.add( dirLightHeper );
 			

 			var pLight = new THREE.PointLight( 0xe3fbdc, 0.9 );
				pLight.position.set(1000,600,0);
				scene.add(pLight);

			var Textureloader = new THREE.TextureLoader();
			var geometry = new THREE.SphereGeometry(1000, 60, 40);  
			var uniforms = {  
			  texture: { type: 't', value: Textureloader.load('Textures/sky1.jpg') }
			};

			var material = new THREE.ShaderMaterial( {  
			  uniforms:       uniforms,
			  side: THREE.DoubleSide,
			  vertexShader:   document.getElementById('sky-vertex').textContent,
			  fragmentShader: document.getElementById('sky-fragment').textContent
			});



			skyBox = new THREE.Mesh(geometry, material);  
			skyBox.scale.set(-1, 1, 1);  
			skyBox.rotation.order = 'XZY';  
			skyBox.renderDepth = 1000.0;  
			scene.add(skyBox);


			//var dirlight = new THREE.DirectionalLight( 0xeeeeff, 0xfff3db, 0.75 );
			//light.position.set( 0.5, 1, 0.75 );
			//scene.add( light );

			//skybox
			

			var boxMaterial = getMaterial('standard', 'rgb(255, 255, 255)');
			var columnMaterial = getMaterial('standard', 'rgb(232, 228, 196)');
			var wallMaterial = getMaterial('standard','rgb(75,0,130)');
			var waterMaterial = getMaterial('standard','rgb(29,162,220)');
		
			
			//entrance getBox(material, length, width, width2, x, z, rotate)
			var entrance1 = getBox(boxMaterial, 10, 50, 20, 50, 400, 0);
			var entrance2 = getBox(boxMaterial, 24, 24, -20, 50, 400, 0);
			var entrance3 = getBox(boxMaterial, 24, 24, 60, 50, 400, 0);
			var entrance4 = getModel("JSON/Foliage/redtree.json", 60, 0, 450, 0);
			var entrance5 = getModel("JSON/Foliage/redtree.json", -70, 0, 450, 0);
			var entrance6 = getModel("JSON/Foliage/redtree.json", 60, 0, 390, 0);
			var entrance7 = getModel("JSON/Foliage/redtree.json", -40, 0, 400, 0);
			var entrance8 = getModel("JSON/Foliage/redtree.json", 50, 0, 300, 0);
			var entrance9 = getModel("JSON/Foliage/redtree.json", -30, 0, 320, 0);

			//trees
			
			//treehouses
			
			var treehouse1 = getModel("JSON/Treehouse/treehouse.json", -350, 0, -80, 0);
			var treehouse2 = getModel("JSON/Treehouse/treehouse.json", -280, 0, -60, 90);
			var treehouse3 = getModel("JSON/Treehouse/treehouse.json", -190, 0, -30, -90);
			var treehouse4 = getModel("JSON/Treehouse/treehouse.json", -350, 0, 60, 0);
			var treehouse5 = getModel("JSON/Treehouse/treehouse.json", -300, 0, 60, 0);
			var treehouse6 = getModel("JSON/Treehouse/treehouse.json", -190, 0, 80,0);
			var treehouse7 = getModel("JSON/Treehouse/treehouse.json", -350, 0, 0,0);
			
			//village
			//getModel(name, x, z, rotateY)
			
			var house1 = getModel("JSON/House/whitehouse.json", -50, 0, -60, 0);
			var house2 = getModel("JSON/House/whitehouse.json", 0, 0, -30, 20);
			var house3 = getModel("JSON/House/whitehouse.json", 45, 0, -25, 50);
			var house4 = getModel("JSON/House/whitehouse.json", 80, 0, 20, -5);
			var house5 = getModel("JSON/House/whitehouse.json", -35, 0, 0, 25);
			var house6 = getModel("JSON/House/whitehouse.json", -20, 0, 50, -5);
			var house7 = getModel("JSON/House/whitehouse.json", -62, 0, 60, -5);
			var house8 = getModel("JSON/House/whitehouse.json", -40, 0, 115, -5);
			var house9 = getModel("JSON/House/whitehouse.json", 75, 0, 100, -5);
			var house10 = getModel("JSON/House/whitehouse.json", 10, 0, 90, -5);
			var house11 = getModel("JSON/House/whitehouse.json", 60, 0, -150, -5);
			var house12 = getModel("JSON/House/whitehouse.json", -50, 0, -130, -5);

			var fountain = getModel("JSON/fountain.json", 15, 0, 45, 0);

			var combohouse = getModel("JSON/House/whitehouse.json", 100, 0, -250, 0);
			//walls(material, length, width, x, y, z)
			var treeblock = getTreeBox(boxMaterial, 20, 5, 0, 30, 0);
			//castle
			
			
			var castletexture = Textureloader.load( 'Textures/castle.jpg' );
			//texture.bumpMap = Textureloader.load( 'Textures/castle.jpg' );
			//texture.bumpScale = 5;
			castletexture.wrapS = THREE.RepeatWrapping;
			castletexture.wrapT = THREE.RepeatWrapping;
			castletexture.repeat.set( 1, 3 );
			castletexture.side = THREE.DoubleSide;
			var castleMaterial = new THREE.MeshBasicMaterial( { map: castletexture, side: THREE.DoubleSide } );
			//getBox(material, length, width, width2, x, z, rotate)
			var entryWall = getModel("JSON/Castle/entry_wall.json", 10, 0, -300, 0);
			var castle = getBox(castleMaterial, 50, 50, 200, 10, -400, 0);
			var bordertower = getModel("JSON/Castle/bordertower.json", -20, 0, -370, 0);
			var bordertower1 = getModel("JSON/Castle/bordertower.json", 40, 0, -370, 0);
			var tower = getModel("JSON/Castle/tower.json", -10, 0, -350, 0);
			var tower1 = getModel("JSON/Castle/tower.json", 30, 0, -350, 0);
			var doorwall = getModel("JSON/Castle/door_wall.json", 10, 0, -350, 0);
			var wall = getModel("JSON/Castle/wall.json", -30, 0, -350, 0);
			var wall1 = getModel("JSON/Castle/wall.json", 45, 0, -350, 0);
			var highTower = getModel("JSON/Castle/high_tower.json", 45, 0, -370, 0);
			var roof = getModel("JSON/Castle/roof.json", 0, 0, 0, 0);
			var longbanner = getModel("JSON/Castle/longbanner.json", 10, -400, 0, 0);
			
			//lagoon
			var lagoon = getBox(boxMaterial, 70, 70, 70, 70, 300, 0);


			//right wall getWall("mountain.json", start, end, rotate);
			var rightWall = getWall("JSON/Foliage/mountain.json", 400, -490, "false");
			var leftWall = getWall("JSON/Foliage/mountain.json", -400, -490, "false");
			var topWall = getOtherWall("JSON/Foliage/mountain.json", -380, -520, "true");
			var bottomWall = getOtherWall("JSON/Foliage/mountain.json", -380, 500, "true");

			//Pillar Land
			//getBox(material, length, width, width2, x, z, rotate)
			var base = getBox(columnMaterial, 100, 130, 20, 280, 320, -40);
			var leftpillar = getModel("JSON/Castle/pillar.json",220, 9, 335,0);
			var toppillar = getModel("JSON/Castle/pillar.json",290, 9, 260,0);
			var rightpillar = getModel("JSON/Castle/pillar.json",340, 9, 300,0);
			var bottompillar = getModel("JSON/Castle/pillar.json",270, 9, 380,0);
		
			//object.rotation.y = 10;
			
			var tree = getModel("JSON/leaftree4.json",-10, 0, 250,10);
			var tree1 = getModel("JSON/leaftree4.json",-10, 0, 200,-40);
			var tree2 = getModel("JSON/leaftree4.json",40, 0, 220,-90);
			var tree3 = getModel("JSON/leaftree4.json",-350, 0, 140,0);
			var tree4 = getModel("JSON/leaftree4.json",-320, 0, 180,50);
			var tree5 = getModel("JSON/leaftree4.json",-290, 0, 140,0);
			var tree6 = getModel("JSON/leaftree4.json",-120, 0, 280,-90);
			var tree7 = getModel("JSON/leaftree4.json",-120, 0, 135,45);
			var tree8 = getModel("JSON/leaftree4.json",-210, 0, 140,90);
			var tree9 = getModel("JSON/leaftree4.json",-150, 0, 180,90);
			var tree10 = getModel("JSON/leaftree4.json",-220, 0, -100,0);
			var tree11 = getModel("JSON/leaftree4.json",-320, 0, -110,30);
			var tree12 = getModel("JSON/leaftree4.json",-130, 0, -200,0);
			var tree13 = getModel("JSON/leaftree4.json",-290, 0, -230,0);
			var tree14 = getModel("JSON/leaftree4.json",-290, 0, -390,-90);
			var tree15 = getModel("JSON/leaftree4.json",-170, 0, -350,0);
			var tree16 = getModel("JSON/leaftree4.json",140, 0, -380,0);
			var tree17 = getModel("JSON/leaftree4.json",140, 0, -380,-30);
			var tree18 = getModel("JSON/leaftree4.json",320, 0, -380,0);
			var tree19 = getModel("JSON/leaftree4.json",300, 0, -300,50);
			var tree20 = getModel("JSON/leaftree4.json",-310, 0, 270, 0);
			var tree21 = getModel("JSON/leaftree4.json",-320, 0, 340, 90);
			var tree22 = getModel("JSON/leaftree4.json",-250, 0, 300, -50);
			var tree23 = getModel("JSON/leaftree4.json",110, 0, -100, 0);
			var tree24 = getModel("JSON/leaftree4.json",160, 0, -70, 0);
			var tree25 = getModel("JSON/leaftree4.json",145, 0, -10, 120);
			var tree26 = getModel("JSON/leaftree4.json",165, 0, 65, -150);
			var tree27 = getModel("JSON/leaftree4.json",180, 0, 170, 0);
			var tree28 = getModel("JSON/leaftree4.json",330, 0, 220, 0);
			var tree29 = getModel("JSON/leaftree4.json",340, 0, 370, 0);
			var tree30 = getModel("JSON/leaftree4.json",180, 0, 370, 0);
			var tree31 = getModel("JSON/leaftree4.json",-220, 0, 390, 0);
			//var utree1 = getModel("JSON/foliage/umbrellatree1.json",-250,10, 0);
			
			//tree.scale.set(50,50,50);
			


			var geom = new THREE.Geometry(); 
			var v1 = new THREE.Vector3(0,0,0);
			var v2 = new THREE.Vector3(0,10,0);
			var v3 = new THREE.Vector3(0,10,10);
			var v4 = new THREE.Vector3(0,-10,10);

			geom.vertices.push(v1);
			geom.vertices.push(v2);
			geom.vertices.push(v3);
			geom.vertices.push(v4);

			geom.faces.push( new THREE.Face3( 0, 1, 2 ) );
			geom.computeFaceNormals();

			var object = new THREE.Mesh( geom, new THREE.MeshNormalMaterial() );

			object.position.z = -100;//move a bit back - size of 500 is a bit big
			object.rotation.y = -Math.PI * .5;//triangle is pointing in depth, rotate it -90 degrees on Y

			scene.add(object);

			dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
			dirLight.color.setHSL( 0.1, 1, 0.95 );
			dirLight.position.set( 5, 5, 5 );
			dirLight.position.multiplyScalar( 100 );
			scene.add( dirLight );
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 2048;
			dirLight.shadow.mapSize.height = 2048;

			//***************************************
			
			controls = new THREE.PointerLockControls(camera);
			scene.add( controls.getObject() );
			var onKeyDown = function ( event ) {
				switch ( event.keyCode ) {
					case 38: // up
					case 87: // w
						moveForward = true;
						break;
					case 37: // left
					case 65: // a
						moveLeft = true; break;
					case 40: // down
					case 83: // s
						moveBackward = true;
						break;
					case 39: // right
					case 68: // d
						moveRight = true;
						break;
					case 32: // space
						if ( canJump === true ) velocity.y += 200;
						canJump = false;
						break;
				}
			};
			var onKeyUp = function ( event ) {
				switch( event.keyCode ) {
					case 38: // up
					case 87: // w
						moveForward = false;
						break;
					case 37: // left
					case 65: // a
						moveLeft = false;
						break;
					case 40: // down
					case 83: // s
						moveBackward = false;
						break;
					case 39: // right
					case 68: // d
						moveRight = false;
						break;
				}
			};
			document.addEventListener( 'keydown', onKeyDown, false );
			document.addEventListener( 'keyup', onKeyUp, false );
			raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );
			
			//***********************************************/
			// floor

			var floorGeometry = new THREE.PlaneGeometry( 800, 1000, 100, 100 );
			floorGeometry.rotateX( - Math.PI / 2 );
			for ( var i = 0, l = floorGeometry.vertices.length; i < l; i += 10 ) {
				var vertex = floorGeometry.vertices[i];
				//vertex.x += Math.random() * 20 - 10;
				vertex.y += Math.random() * 2;
				//vertex.z += Math.random() * 20 - 10;
			}
			/*for ( var i = 0, l = floorGeometry.faces.length; i < l; i ++ ) {
				var face = floorGeometry.faces[ i ];
				face.vertexColors[ 0 ] = new THREE.Color().setHSL( Math.random() * 1.23 + 1, 0.75, 0.38  );
				face.vertexColors[ 1 ] = new THREE.Color().setHSL( 1.23, 0.75, 0.38  );
				face.vertexColors[ 2 ] = new THREE.Color().setHSL( 1.23, 0.75, 0.38  );
			}*/
			
			
			var texture = Textureloader.load( 'Textures/basicmap.jpg' );
			texture.bumpMap = Textureloader.load( 'Textures/basicmap.jpg' );
			texture.bumpScale = 5;
			/*texture.wrapS = THREE.RepeatWrapping;*/
			/*texture.wrapT = THREE.RepeatWrapping;*/
			//texture.repeat.set( 20, 20 );
			var floorMaterial = new THREE.MeshBasicMaterial( { map: texture } );

			//var floorMaterial = new THREE.MeshBasicMaterial( { color:0x228B22 } );
			var floor = new THREE.Mesh( floorGeometry, floorMaterial );
			floor.position.set(0,0,0);
			scene.add( floor );
			
			//
			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			//
			window.addEventListener( 'resize', onWindowResize, false );
		}

		function getModel(name, x, y, z, rotateY) {
			var loader = new THREE.ObjectLoader();
				loader.load(name,function ( obj ) {
				     //var object = obj;
				     obj.position.set(x,y,z);
				     //object.matrix.scale(50,50,50);
				     obj.rotation.y = rotateY;
				     obj.recieveShadow = true;
				     obj.castShadow = true;
				     objects.push( obj );
				     scene.add( obj );
				     return obj;


		    });
		}

		function getBox(material, length, width, width2, x, z, rotate) {
			var geometry = new THREE.BoxGeometry(width, width2, length);
			var obj = new THREE.Mesh(geometry, material);
			obj.side = THREE.DoubleSide;
			obj.castShadow = true;
			obj.recieveShadow = true;
			obj.rotation.y = rotate;
			obj.position.x = x;
			obj.position.z = z;
			obj.position.y = 0;
			objects.push( obj );
			scene.add(obj);
			return obj;
		}

		function getTreeBox(material, length, width, x, y, z) {
			var geometry = new THREE.BoxGeometry(width, width, length);
			var obj = new THREE.Mesh(geometry, material);
			obj.castShadow = true;
			obj.position.x = x;
			obj.position.z = z;
			obj.position.y = y;
			objects.push( obj );
			scene.add(obj);
			return obj;
		}

		function getWall(name, start, end, rotate) {
			var loader = new THREE.ObjectLoader();
				
				loader.load(name,function ( obj ) {
				     var object = obj;
				     
				 
				     	object.position.set(start,0,end);
				     	objects.push( object );
				        scene.add( object );
				        //32
				     	if(end < 490){
				     		getWall("JSON/Foliage/mountain.json", start, end+100, "false");
				     	}


		    });
		
		}

		function getOtherWall(name, start, end, rotate) {
			var loader = new THREE.ObjectLoader();
				
				loader.load(name,function ( obj ) {
				     var object = obj;
				    
				     	obj.rotation.y = -Math.PI / 2;
				     	obj.position.set(start,0,end);
				     	objects.push( obj );
				        scene.add( obj );

				        //35
				     	if(start < 400){
				     		getOtherWall("JSON/Foliage/mountain.json", start+100, end, "true");
				     	} 


		    });
		
		}

		function getMaterial(type, color) {
			var selectedMaterial;
			var materialOptions = {
				color: color === undefined ? 'rgb(255, 255, 255)' : color,
			};

			switch (type) {
				case 'basic':
					selectedMaterial = new THREE.MeshBasicMaterial(materialOptions);
					break;
				case 'lambert':
					selectedMaterial = new THREE.MeshLambertMaterial(materialOptions);
					break;
				case 'phong':
					selectedMaterial = new THREE.MeshPhongMaterial(materialOptions);
					break;
				case 'standard':
					selectedMaterial = new THREE.MeshStandardMaterial(materialOptions);
					break;
				default: 
					selectedMaterial = new THREE.MeshBasicMaterial(materialOptions);
					break;
			}

			return selectedMaterial;
		}



		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}

		var x = 0;
		function animate() {
			requestAnimationFrame( animate );

			if ( controlsEnabled === true ) {
				raycaster.ray.origin.copy( controls.getObject().position );
				raycaster.ray.origin.y -= 10;
				var intersections = raycaster.intersectObjects( objects );
				var onObject = intersections.length > 0;
				var time = performance.now();
				var delta = ( time - prevTime ) / 1000;
				var timeElapsed = clock.getElapsedTime();
				velocity.x -= velocity.x * 30.0 * delta;
				velocity.z -= velocity.z * 30.0 * delta;
				velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass
				direction.z = Number( moveForward ) - Number( moveBackward );
				direction.x = Number( moveLeft ) - Number( moveRight );
				//direction.y = Number( moveUp ) - Number( moveDown );
				direction.normalize(); // this ensures consistent movements in all directions
				



				if ( moveForward || moveBackward ) {
					velocity.z -= direction.z * 400.0 * delta; 
				    //controls.getObject().position.y += Math.sin(0); 
				    /*x += 1;*/
				    //increase = (Math.sin(timeElapsed * 5 + index) + 1) / 2 + 0.001;
				    ////index += 0.01;
				    //console.log("Seconds:" + index);
				    ////velocity.y -= index;
				    //console.log(Math.sin(index));
				    //controls.getObject().position.y = Math.sin(index);
				    /*if (x > 1){
				    	x = 0;
				    }*/
				    if(onObject === true){
				    	console.log("You touched the butt");
				    	//velocity.z += direction.z * 400.0 * delta; 
				    }
				    ////var yPosition = controls.getObject().position.y;
				    //console.log("Y position" + yPosition);
			
				    //camera.position.y = (sin(x) + sin(x));
				    //console.log(Math.sin(timeElapsed - (timeElapsed - 1)));
				    //velocity.y += direction.z * 400.0 * delta;
				}
				if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;
				if ( onObject === true ) {
					velocity.y = Math.max( 0, velocity.y );
					canJump = true;
				}
				controls.getObject().translateX( velocity.x * delta );
				controls.getObject().translateY( velocity.y * delta );
				controls.getObject().translateZ( velocity.z * delta );
				if ( controls.getObject().position.y < 10 ) {
					velocity.y = 0;
					controls.getObject().position.y = 10;
					canJump = true;
				}
				prevTime = time;
			}
			renderer.render( scene, camera );
		}
	</script>
</body>
</html>